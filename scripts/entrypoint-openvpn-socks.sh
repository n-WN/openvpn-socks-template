#!/bin/sh
set -eu

log() {
  printf '[%s] %s\n' "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" "$*"
}

OPENVPN_CONFIG="${OPENVPN_CONFIG:-/vpn/client.ovpn}"
OPENVPN_AUTH_USER="${OPENVPN_AUTH_USER:-}"
OPENVPN_AUTH_PASS="${OPENVPN_AUTH_PASS:-}"

# Support reading credentials from file (avoids .env # comment issues)
OPENVPN_AUTH_FILE="${OPENVPN_AUTH_FILE:-/vpn/auth.txt}"
if [ -f "$OPENVPN_AUTH_FILE" ]; then
  OPENVPN_AUTH_USER=$(sed -n '1p' "$OPENVPN_AUTH_FILE")
  OPENVPN_AUTH_PASS=$(sed -n '2p' "$OPENVPN_AUTH_FILE")
  log "loaded credentials from $OPENVPN_AUTH_FILE"
fi
OPENVPN_EXTRA_ARGS="${OPENVPN_EXTRA_ARGS:-}"
OPENVPN_LOG="${OPENVPN_LOG:-/var/log/openvpn.log}"
OPENVPN_VERB="${OPENVPN_VERB:-3}"
USE_VPN_DNS="${USE_VPN_DNS:-1}"
VPN_DNS="${VPN_DNS:-}"
STREAM_OPENVPN_LOG="${STREAM_OPENVPN_LOG:-0}"
STREAM_OPENVPN_LOG_LINES="${STREAM_OPENVPN_LOG_LINES:-+1}"

SOCKS5_PORT="${SOCKS5_PORT:-1080}"
SOCKS5_BIND="${SOCKS5_BIND:-0.0.0.0}"
SOCKS5_USER="${SOCKS5_USER:-}"
SOCKS5_PASS="${SOCKS5_PASS:-}"
SOCKS_LOG="${SOCKS_LOG:-error}"
SOCKS_MAX_CONN="${SOCKS_MAX_CONN:-50}"
SOCKS_CLIENT_CIDRS="${SOCKS_CLIENT_CIDRS:-0.0.0.0/0}"

ENABLE_KILL_SWITCH="${ENABLE_KILL_SWITCH:-0}"

if [ ! -f "$OPENVPN_CONFIG" ]; then
  log "fatal: OPENVPN_CONFIG not found: $OPENVPN_CONFIG"
  exit 1
fi

mkdir -p /var/log /run /etc/dante
AUTH_FILE=""

if [ -n "$OPENVPN_AUTH_USER" ] || [ -n "$OPENVPN_AUTH_PASS" ]; then
  if [ -z "$OPENVPN_AUTH_USER" ] || [ -z "$OPENVPN_AUTH_PASS" ]; then
    log "fatal: both OPENVPN_AUTH_USER and OPENVPN_AUTH_PASS must be set for auth-user-pass"
    exit 1
  fi
  AUTH_FILE="/run/openvpn-auth.txt"
  {
    printf '%s\n' "$OPENVPN_AUTH_USER"
    printf '%s\n' "$OPENVPN_AUTH_PASS"
  } >"$AUTH_FILE"
  chmod 600 "$AUTH_FILE"
fi

ensure_tun() {
  # ensure /dev/net/tun exists (helps Docker Desktop/macOS environments)
  if [ ! -e /dev/net ]; then
    mkdir -p /dev/net || true
  fi
  if [ ! -c /dev/net/tun ]; then
    mknod /dev/net/tun c 10 200 2>/dev/null || true
    chmod 600 /dev/net/tun 2>/dev/null || true
  fi
}

wait_for_tun() {
  tries=0
  warn_after=30
  while ! ip link show dev tun0 >/dev/null 2>&1; do
    tries=$((tries+1))
    if [ $tries -eq $warn_after ]; then
      log "warning: tun0 not available after ${warn_after}s; waiting (socks will start once tun0 is up)"
    fi
    sleep 1
  done
  log "tun0 is up"
}

ipv4_of() {
  dev="$1"
  ip -o -4 addr show dev "$dev" 2>/dev/null | awk '{print $4}' | cut -d/ -f1 | head -n1 || true
}

print_net_info() {
  ETH0_IP="$(ipv4_of eth0)"
  TUN0_IP="$(ipv4_of tun0)"
  HOST_IP=""
  if command -v getent >/dev/null 2>&1; then
    HOST_IP="$(getent hosts host.docker.internal 2>/dev/null | awk '{print $1}' | head -n1 || true)"
  fi
  log "socks5 will listen on ${SOCKS5_BIND}:${SOCKS5_PORT}"
  [ -n "$ETH0_IP" ] && log "container eth0 IPv4: $ETH0_IP"
  [ -n "$TUN0_IP" ] && log "container tun0 IPv4: $TUN0_IP"
  if [ -n "$HOST_IP" ]; then
    log "host.docker.internal resolves to: $HOST_IP (on macOS/Windows, connect via $HOST_IP:${SOCKS5_PORT} or localhost:${SOCKS5_PORT})"
  else
    log "tip: from the host, connect to localhost:${SOCKS5_PORT} (if -p published) or your host LAN IP"
  fi
}

gen_dante_config() {
  cat >/etc/dante/sockd.conf <<EOF
logoutput: stderr
internal: ${SOCKS5_BIND} port = ${SOCKS5_PORT}
external: tun0
socksmethod: $( [ -n "$SOCKS5_USER" ] && echo username || echo none )
clientmethod: none
user.privileged: root
user.notprivileged: nobody
client pass {
  from: ${SOCKS_CLIENT_CIDRS} to: 0.0.0.0/0
  log: ${SOCKS_LOG}
}
socks pass {
  from: 0.0.0.0/0 to: 0.0.0.0/0
  log: ${SOCKS_LOG}
}
EOF
}

write_resolv_conf() {
  # write resolv.conf with given nameservers
  {
    echo "# generated by openvpn-socks entrypoint";
    for ns in "$@"; do
      echo "nameserver $ns";
    done
  } >/etc/resolv.conf
}

apply_vpn_dns() {
  [ "$USE_VPN_DNS" = "0" ] && { log "USE_VPN_DNS=0; skip DNS update"; return 0; }
  dns_list=""
  if [ -f "$OPENVPN_LOG" ]; then
    dns_list=$(grep -oE 'dhcp-option DNS [0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' "$OPENVPN_LOG" 2>/dev/null | awk '{print $3}' | awk '!seen[$0]++') || true
  fi
  if [ -z "$dns_list" ] && [ -n "$VPN_DNS" ]; then
    dns_list=$(echo "$VPN_DNS" | tr ',' ' ')
  fi
  if [ -n "$dns_list" ]; then
    log "applying VPN DNS: $dns_list"
    # shellcheck disable=SC2086
    write_resolv_conf $dns_list
  else
    log "info: no VPN DNS discovered; leaving /etc/resolv.conf unchanged"
  fi
}

start_openvpn() {
  cfgpath="$OPENVPN_CONFIG"
  cfgdir=$(dirname "$cfgpath")
  cfgbase=$(basename "$cfgpath")
  set -- openvpn --cd "$cfgdir" --config "$cfgbase" \
    --writepid /run/openvpn.pid \
    --log "$OPENVPN_LOG"

  if [ -n "$AUTH_FILE" ]; then
    set -- "$@" --auth-user-pass "$AUTH_FILE"
  fi

  # If user did not supply explicit up/down hooks, inject our DNS hook
  HOOKED=0
  case " ${OPENVPN_EXTRA_ARGS} " in
    *" --up "*|*" --down "*|*" --script-security "*) HOOKED=1 ;;
  esac
  if [ "$HOOKED" = "0" ]; then
    set -- "$@" --script-security 2 --up /etc/openvpn/scripts/update-resolv.sh --down /etc/openvpn/scripts/update-resolv.sh
  fi

  # Apply verbosity unless user overrode via EXTRA_ARGS
  case " ${OPENVPN_EXTRA_ARGS} " in
    *" --verb "*|*" --verb="*) : ;; # user supplied
    *) set -- "$@" --verb "$OPENVPN_VERB" ;;
  esac

  if [ -n "$OPENVPN_EXTRA_ARGS" ]; then
    # shellcheck disable=SC2086
    set -- "$@" $OPENVPN_EXTRA_ARGS
  fi

  log "starting openvpn with config $OPENVPN_CONFIG"
  "$@" &
  OVPN_PID=$!
  log "openvpn pid: $OVPN_PID"
}

start_socks() {
  gen_dante_config
  if [ -n "$SOCKS5_USER" ] || [ -n "$SOCKS5_PASS" ]; then
    if [ -z "$SOCKS5_USER" ] || [ -z "$SOCKS5_PASS" ]; then
      log "fatal: both SOCKS5_USER and SOCKS5_PASS must be set for proxy auth"
      exit 1
    fi
    # create passwd entry for dante's username auth; uses /etc/passwd auth via system accounts
    adduser -D "$SOCKS5_USER" || true
    echo "$SOCKS5_USER:$SOCKS5_PASS" | chpasswd
  fi
  log "starting dante sockd on ${SOCKS5_BIND}:${SOCKS5_PORT} (daemon) with max-conn=${SOCKS_MAX_CONN}"
  # Use -N 1 (single main process) to reduce fork overhead; maxworkers in config controls concurrency
  sockd -f /etc/dante/sockd.conf -N 1 -D
}

configure_killswitch() {
  [ "$ENABLE_KILL_SWITCH" = "1" ] || return 0
  log "enabling kill-switch (iptables)"
  # Determine remote host/port/proto from ovpn file
  cfgpath="$OPENVPN_CONFIG"
  cfgdir=$(dirname "$cfgpath"); cfgbase=$(basename "$cfgpath")
  # Read from the ovpn file directly
  remote_line=$(grep -E '^\s*remote\s+' "$cfgpath" | head -n1 || true)
  proto_line=$(grep -E '^\s*proto\s+' "$cfgpath" | head -n1 || true)
  remote_host=$(printf '%s\n' "$remote_line" | awk '{print $2}')
  remote_port=$(printf '%s\n' "$remote_line" | awk '{print $3}')
  proto=$(printf '%s\n' "$proto_line" | awk '{print $2}')
  [ -n "$proto" ] || proto=tcp
  [ -n "$remote_port" ] || remote_port=1194
  # Resolve host to IP (prefers getent)
  remote_ip=""
  if command -v getent >/dev/null 2>&1; then
    remote_ip=$(getent hosts "$remote_host" | awk '{print $1}' | head -n1 || true)
  fi
  if [ -z "$remote_ip" ]; then
    remote_ip=$(sh -lc "nslookup $remote_host 2>/dev/null | awk '/^Address [0-9]*: /{print \$3; exit} /^Address: /{print \$2; exit}'" || true)
  fi
  # Allow current resolvers for DNS lookups (for resilience)
  resolvers=$(awk '/^nameserver /{print $2}' /etc/resolv.conf | awk '!seen[$0]++')
  # Apply OUTPUT policy; be careful to not lock ourselves out mid-script
  iptables -P OUTPUT DROP || true
  iptables -F OUTPUT || true
  # 1) allow loopback
  iptables -A OUTPUT -o lo -j ACCEPT
  # 2) allow established
  iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
  # 3) allow VPN tunnel egress
  iptables -A OUTPUT -o tun+ -j ACCEPT
  # 4) allow DNS to current resolvers
  for ns in $resolvers; do
    iptables -A OUTPUT -o eth0 -p udp -d "$ns" --dport 53 -j ACCEPT
    iptables -A OUTPUT -o eth0 -p tcp -d "$ns" --dport 53 -j ACCEPT
  done
  # 5) allow OpenVPN remote endpoint
  if [ -n "$remote_ip" ]; then
    case "$proto" in
      tcp) iptables -A OUTPUT -o eth0 -p tcp -d "$remote_ip" --dport "$remote_port" -j ACCEPT ;;
      udp) iptables -A OUTPUT -o eth0 -p udp -d "$remote_ip" --dport "$remote_port" -j ACCEPT ;;
      *) iptables -A OUTPUT -o eth0 -p tcp -d "$remote_ip" --dport "$remote_port" -j ACCEPT ;;
    esac
  else
    log "warning: could not resolve remote host '$remote_host' for kill-switch; only DNS allowed"
  fi
  log "kill-switch rules applied"
}

ensure_tun
configure_killswitch

# Start OpenVPN (background) and keep container lifecycle bound to it
start_openvpn

# Optional: continuously stream OpenVPN log to stdout so `docker logs` stays fresh
if [ "$STREAM_OPENVPN_LOG" = "1" ]; then
  i=0
  while [ ! -f "$OPENVPN_LOG" ] && [ $i -lt 30 ]; do i=$((i+1)); sleep 1; done
  if [ -f "$OPENVPN_LOG" ]; then
    # shellcheck disable=SC2086
    tail -n $STREAM_OPENVPN_LOG_LINES -F "$OPENVPN_LOG" &
  else
    log "warning: $OPENVPN_LOG not found; skip streaming"
  fi
fi

wait_for_tun
apply_vpn_dns || true
print_net_info

# Start sockd only after tun is up
start_socks

# Ensure container exits when openvpn exits
trap 'kill -TERM $OVPN_PID 2>/dev/null || true; exit 0' TERM INT
wait $OVPN_PID
exit $?
